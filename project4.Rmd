---
title: "Chapter 1: Data tidying using tidyr"
description: |
  Learn how to make your data tidy with the tidyr package.
author:
  - name: Jewel Johnson 
date: "`r Sys.Date()`"
output: 
  distill::distill_article:
    toc_depth: 3
---
```{r setup, include=FALSE}
library(dplyr)
library(tidyr)
library(rmarkdown)
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
```

---
#start editing from here
---

## Introduction to tidyr package

Raw data might not be always in a usable form for any form of analysis or visualization processes. The `tidyr` package aims to help you in reshaping your data in a usable form. In short it helps you to 'tidy' up your data using various tools. In this chapter we will see how you can use the `tidyr` package to make your data tidy.

## What is tidy data?

First, we need to understand what a tidy data looks like. For that let us imagine a scenario where you are a doctor who is trying find the best treatment for a disease . Now your colleagues have short-listed five different treatment methods and have reported their efficacy values when tested with five different patients. Now you are tasked with finding which of the five treatments is the best against the disease. You open your computer and you find the following data of the experiment. 

```{r, echo=FALSE}
patient1 <- c(seq(1,5,1))
patient2 <- c(seq(6,10,1))
patient3 <- c(seq(11,15,1))
patient4 <- c(seq(16,20,1))
patient5 <- c(seq(21,25,1))

treatment_data <- cbind(patient1,patient2,patient3,patient4,patient5)
trt <- c("treatment1", "treatment2","treatment3","treatment4","treatment5")
treatment_data <- cbind(trt, treatment_data)
treatment_data <- as.data.frame(treatment_data)
paged_table(treatment_data)
```

This is how often data is stored because it is easy to write it this way. In the first column you can see the different treatments from one to five. And in the second column you have the efficacy values of the treatments for patient 1 and it goes on for the other patients. Now this is a good example of how a dataset should not look like! Surprised? Let us see what makes this dataset 'dirty'. 

You can quickly notice that, there is no mentioning of what these numerical values mean. Of course we know that they are efficacy values for the different treatments. But for someone who only have this data as a reference, that person would not have a clue to what these numbers mean. Also note that each of the rows contains multiple observation values which is not a feature of a tidy data. These kind of data format is called as 'wide data' which we will talk more about later.

With that being said, a tidy data will have; 

1. Each of it's variables represented in it's own columns
2. Each observation or a case in it's own row. 
3. Each of the the rows will contain only a single value.

So let us see how the 'tidier' version of this data would look like.

```{r, echo=FALSE}
patient1 <- c(seq(1,5,1))
patient2 <- c(seq(6,10,1))
patient3 <- c(seq(11,15,1))
patient4 <- c(seq(16,20,1))
patient5 <- c(seq(21,25,1))

treatment_data <- cbind(patient1,patient2,patient3,patient4,patient5)

trt <- c("treatment1", "treatment2","treatment3","treatment4","treatment5")

treatment_data <- cbind(trt, treatment_data)
treatment_data <- as.data.frame(treatment_data)

treatment_data_tidy <-treatment_data  %>% 
  pivot_longer(colnames(treatment_data[,-1]), names_to = "patient_ID", values_to = "efficacy")

colnames(treatment_data_tidy)[1] <- "treatment"
paged_table(treatment_data_tidy)
```

You can see each of columns represent only one type of variable. In the first column you have the types of treatments, followed by patient IDs and their efficacy values for each treatment. Also note that each row represent only one observation. So this kind of data format is what we strive to achieve by using the `tidyr` package and they are called as 'long data'. So let us begin!

## tidyr commands

There are different sets of command which you can utilize to reshape your data and make it tidy. Let us each of these commands in action

### pivot_longer()

The `pivot_longer()` command converts a 'wide data' to a 'long data'. It does so by converting row names to a new column under a new variable name with its corresponding values moved into another column with another variable name. So let us see how it goes. We will take the earlier mentioned example and will see how to make it tidy. Now you don't have to be concerned with the codes I have used to make the dummy data. Just have your focus on the `pivot_longer()` syntax.

```{r, eval=FALSE}
#making a dummy data
#using sample function to pick random numbers in a sequence
patient1 <- c(seq(1,5,1))
patient2 <- c(seq(6,10,1))
patient3 <- c(seq(11,15,1))
patient4 <- c(seq(16,20,1))
patient5 <- c(seq(21,25,1))

#cbind simple combines the columns of same size
treatment_data <- cbind(patient1,patient2,patient3,patient4,patient5) 

trt <- c("treatment1", "treatment2","treatment3","treatment4","treatment5")

trt_data <- cbind(trt, treatment_data)
trt_data <- as.data.frame(trt_data) #making it a data frame

trt_data_tidy <- pivot_longer(trt_data,
                              c(patient1,patient2,patient3,patient4,patient5), 
                              names_to = "patient_ID", values_to = "efficacy")
trt_data_tidy
```

```{r, echo=FALSE}
patient1 <- c(seq(1,5,1))
patient2 <- c(seq(6,10,1))
patient3 <- c(seq(11,15,1))
patient4 <- c(seq(16,20,1))
patient5 <- c(seq(21,25,1))
treatment_data <- cbind(patient1,patient2,patient3,patient4,patient5) 
treatment <- c("treatment1", "treatment2","treatment3","treatment4","treatment5")
trt_data <- cbind(treatment, treatment_data)
trt_data <- as.data.frame(trt_data) 
trt_data_tidy <- pivot_longer(trt_data,
                              c(patient1,patient2,patient3,patient4,patient5), 
                              names_to = "patient_ID", values_to = "efficacy")
paged_table(trt_data_tidy)
```

Further more, you dont have manually type in the column names as you can use `colnames()` to call the column names of the dataset. Another way of doing the same is by excluding the first column from the process. By doing so the command will automatically pivot all columns except the excluded one, so in this way we don't need to manually specify the column names. Codes given below will give you the same result as before.

```{r, code.folding=TRUE}
patient1 <- c(seq(1,5,1))
patient2 <- c(seq(6,10,1))
patient3 <- c(seq(11,15,1))
patient4 <- c(seq(16,20,1))
patient5 <- c(seq(21,25,1))
treatment_data <- cbind(patient1,patient2,patient3,patient4,patient5) 
treatment <- c("treatment1", "treatment2","treatment3","treatment4","treatment5")
trt_data <- cbind(treatment, treatment_data)
trt_data <- as.data.frame(trt_data)
#using colnames, [-1] is included to exclude the name of first column from the process
trt_data_tidy1 <- pivot_longer(trt_data,
                              colnames(trt_data)[-1], 
                              names_to = "patient_ID", values_to = "efficacy")

#the same can be done by manually specifying which columns to exclude
#this can be done by denoting the column name ('treatment' in this case) with '-' sign
trt_data_tidy2 <- pivot_longer(trt_data, names_to = "patient_ID", values_to = "efficacy",
                              -treatment)
#checking if both the tidy datasets are one and the same
paged_table(as.data.frame(trt_data_tidy1 == trt_data_tidy2), options = list(rows.print = 5))
```


The syntax for `pivot_longer()` is given below with description

```{r, eval=FALSE}
pivot_longer("data", c("colname1, colname2,....."), 
  names_to = "name of the column where your row names are present",
  values_to = "name of the column where your corresponding row values are present")
```

Here is a graphical representation 

![](photos/pivot_longer().png)

### pivot_wider()

The `pivot_wider()` does the exact opposite of what `pivot_longer()` does, which is to convert a long data into wide data. We will use the earlier example. 

```{r}
#making a dummy data
#using sample function to pick random numbers in a sequence
patient1 <- c(seq(1,5,1))
patient2 <- c(seq(6,10,1))
patient3 <- c(seq(11,15,1))
patient4 <- c(seq(16,20,1))
patient5 <- c(seq(21,25,1))

#cbind simple combines the columns of same size
treatment_data <- cbind(patient1,patient2,patient3,patient4,patient5) 

trt <- c("treatment1", "treatment2","treatment3","treatment4","treatment5")

trt_data <- cbind(trt, treatment_data)
trt_data <- as.data.frame(trt_data) #making it a data frame

trt_data_tidy <- pivot_longer(trt_data,
                              c(patient1,patient2,patient3,patient4,patient5), 
                              names_to = "patient_ID", values_to = "efficacy")

#making the data wide
trt_data_wider <- pivot_wider(trt_data_tidy, names_from = "patient_ID", values_from = "efficacy")
#paged_Table() for viewing the dataset as a table, 
#you can see that the dataset is same as before
paged_table(as.data.frame(trt_data_wider))
```

The syntax for `pivot_wider()` is given below with description

```{r, eval=FALSE}
pivot_longer("data", 
  names_from = "name of the column which contains your wide data columns",
  values_from = "name of the column where your corresponding wide data column values are")
```

Here is a graphical representation

![](photos/pivot_wider().png)

## Summary




## References
